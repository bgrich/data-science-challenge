---
title: "Exploratory Data Analysis"
output: 
  html_notebook:
    toc: true
    toc_float: true
---

```{r setup, message = FALSE}
library(tidyverse)
library(jsonlite)
```

The two questions that I have been asked to answer to the Room Key Data 
Science Challenge are: 

* What factors correlate with users booking? 
* What can Room Key do to increase booking conversion rate?

To begin, I want to do some exploratory data analysis to get a sense for the 
data.

# Data Import

The first step is to import the data to R. The data is stored as a tab-separated 
value format with three columns. The elements of each column contain an entry 
for referrals, leads, and booking in JSON format.

```{r, message = FALSE}
room_key_data <- read_tsv("data.tsv", progress = FALSE)
```

With the data imported, I want to take a peak at what it looks like. 

```{r}
room_key_data
```

In this form the data is pretty difficult to parse. I want to take each column 
of the `room_key_data` object (referral, lead, and booking) and split them into 
individual data sets. These individual data sets can then be parsed by their 
JSON format and turned into a data frame. 

# Data Cleaning

The first step of the data cleaning will be to split each data set apart. For 
each of the data sets, I will filter out the null entries as these are ones 
that did not lead to any leads or booking. The filtering step will also occur 
for the referral set, but it should not lead to the removal of any entries. 
The `fromJSON` function will then be applied to every element of the column 
and a new data frame will be formed with all of the information spread out 
for each data set.

## Referral

The first set to look at is the referral set. 

```{r}
referral <- room_key_data %>% 
  filter(referral != "null") %>%
  .$referral %>% 
  map_df(fromJSON)
```

Note that converting this into a data frame is time intensive. Here is a peak 
at the completed data frame. 

```{r}
referral
```

## Lead

Next I want to convert the lead column into a data frame.

```{r}
lead <- room_key_data %>% 
  filter(lead != "null") %>%
  .$lead %>% 
  map_df(fromJSON)
```

Here is the lead data set. 

```{r}
lead
```

## Booking

Lastly, I want to convert the booking data set into a data frame. 

```{r}
booking <- room_key_data %>% 
  filter(booking != "null") %>%
  .$booking %>% 
  map_df(fromJSON)
```

And here is the booking data set.

```{r}
booking
```

# Data Details

Now I want to explore the details of each data set. What kind of variables 
am I working with in each one? 

## Referral 

In the referral data set there are 9 columns. 

* visitor-id 
* event-id
* ts 
* type 
* location-tid 
* partner-code 
* check-in 
* check-out 
* udicode

```{r}
room_key_data %>% 
  filter(booking != "null") %>% 
  rownames_to_column() %>% 
  filter(rowname == 1) %>% 
  select(-rowname)
```

Doing a visual inspection of an observation that contains a referral, lead, 
and booking, it appears that the `visitor-id` variable is a unique identifier 
for a user/visitor. The `event-id` variable however is not a unique identifier 
of an observation within, but rather an identifier for an individual referral, 
lead, or booking event. That is to say, for a single row there are different 
event-id's for each referral, lead, and booking event.

To get a sense of what each column contains I am going to do a few simple 
explorations. First, the total number of observations.

```{r}
referral %>% 
  count()
```

Next, the number of distinct event-id's.

```{r}
referral %>% 
  distinct(`event-id`) %>% 
  count()
```

The number of distinct event-id's and the total number of observations are 
equal, indicating that the `event-id` column does truly represent each unique 
referral event. 

Next, I want to understand what the `ts` column is. It appears to be a large 
number and may be a timestamp written in Unix time. 

```{r}
referral %>% 
  select(ts) %>% 
  mutate(timestamp = lubridate::as_datetime(ts))
```

The timestamps produced assuming that `ts` is in Unix time of seconds produces 
timestamps in the year 49757 which is obviously incorrect. If I assume that the 
`ts` column is actually in units of milliseconds then I get the following 
timestamps.

```{r}
referral %>% 
  select(ts) %>% 
  mutate(timestamp = lubridate::as_datetime(ts / 1000)) %>% 
  summarize(min_date = min(timestamp), max_date = max(timestamp))
```

These timestamps match the date range given in the challenge prompt.

